import { GetServerSideProps, NextPage } from "next";
import { useCallback, useEffect, useState, useRef } from "react";
import Head from "next/head";
import Modal from "react-modal";
import styled from "styled-components";
import Header from "@/components/Header";
import Slider from "@/components/Slider";
import SliderItem from "@/components/Slider/item";
// import { homeItems } from "@/data/home";
import { primaryColor } from "@/styles/theme";
import { device } from "@/styles/media";
import useModal from "@/hooks/useModal";
import TalkModal from "@/components/Modal/talk";
import CircleButton from "@/components/Button/circleButton";
import SliderHighlight from "@/components/Slider/highlight";
import { getCaseMetas, getTags } from "@/utils/firebase";
import { CaseMeta } from "@/models/case";
import { PlayfairDisplayFont } from "@/styles/font";

interface Props {
  tags: string[];
  metas: CaseMeta[];
}

interface HState {
  pos: {
    x: number;
    y: number;
  };
  show: boolean;
  image: string;
  id: string | null;
}

const Home: NextPage<Props> = ({ tags, metas }) => {
  const center = Math.round(tags.length / 2);
  const item1 = tags.slice(0, center);
  const item2 = tags.slice(center, tags.length);
  const { isOpen, modal, toggle, setModal } = useModal({});
  const [highlight, setHighlight] = useState<HState>({
    pos: {
      x: 0,
      y: 0,
    },
    show: false,
    image: "",
    id: null,
  });
  const posRef = useRef({
    x: 0,
    y: 0,
  });

  const timeout = useRef<ReturnType<typeof setTimeout>>();

  const preload = useCallback(() => {
    for (let m of metas) {
      const img = new Image();
      img.src = m.imageUrl;
    }
  }, [metas]);

  useEffect(() => {
    setModal(<TalkModal close={toggle} />);
    preload();
  }, [preload, setModal, toggle]);

  const handleTag = useCallback(
    (e: MouseEvent) => {
      posRef.current = {
        x: e.clientX,
        y: e.clientY,
      };

      clearTimeout(timeout.current);

      timeout.current = setTimeout(() => {
        const target = e.target as HTMLAnchorElement;

        const selectedMetas = metas.filter((m) =>
          m.tag.some((v) => v === target.innerHTML)
        );

        let select =
          selectedMetas[Math.floor(Math.random() * selectedMetas.length)];

        // If there is not meta which tag equal to hover item
        // random a meta
        if (!select) {
          select = metas[Math.floor(Math.random() * metas.length)];
          // console.log("Not Select Tag, Random one");
        } else {
          // console.log("Select Tag");
        }

        setHighlight({
          pos: {
            x: posRef.current.x,
            y: posRef.current.y,
          },
          show: true,
          image: select.imageUrl,
          id: select.id,
        });
      }, 0);
    },
    [metas]
  );

  const handleHide = useCallback(() => {
    setHighlight({
      // ...highlight,
      pos: {
        x: posRef.current.x,
        y: posRef.current.y,
      },
      show: false,
      image: "",
      id: null,
    });
  }, []);

  return (
    <>
      <Head>
        <title>Ingsist</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <HomeContainer>
        <Header />

        <Main>
          <SliderContainer>
            <Slider
              initialOffsetX={0}
              contentWidth={1920}
              mouseCallback={handleTag}
              hideCallback={handleHide}
            >
              {[...item1, ...item2].map((item, i) => (
                <SliderItem key={i} text={item} width={100} />
              ))}
            </Slider>

            <Slider
              initialOffsetX={100}
              contentWidth={1920}
              mouseCallback={handleTag}
              hideCallback={handleHide}
            >
              {[...item2, ...item1].map((item, i) => (
                <SliderItem key={i} text={item} width={100} />
              ))}
            </Slider>

            <SliderHighlight
              pos={highlight.pos}
              show={highlight.show}
              image={highlight.image}
              id={highlight.id || "0"}
            />
          </SliderContainer>

          <Intro>
            <h1 className={PlayfairDisplayFont.className}>
              We build <br />
              the digital <br className="phone" />
              experience,
              <br />
              and make it <br className="phone" />
              happen.
            </h1>

            <h2 className={PlayfairDisplayFont.className}>
              A Digital Product Agency
              <br />
              Based in Taipei, Taiwan.
            </h2>
          </Intro>

          <svg>
            <filter id="noise">
              <feTurbulence id="turbulence">
                <animate
                  attributeName="baseFrequency"
                  dur="50s"
                  values="0.9 0.9;0.8 0.8;0.9 0.9;"
                  repeatCount={"indefinite"}
                ></animate>
              </feTurbulence>
              <feDisplacementMap
                in="SourceGraphic"
                scale="60"
              ></feDisplacementMap>
            </filter>
          </svg>
          <Bg />

          <FloatContainer>
            <CircleButton text={`LET'S\nTALK`} onClick={toggle} />
          </FloatContainer>
        </Main>

        <Modal
          isOpen={isOpen}
          // onAfterOpen={afterOpenModal}
          // onRequestClose={closeModal}
          className="Modal"
          overlayClassName="Overlay"
          contentLabel="Example Modal"
        >
          {modal}
        </Modal>
      </HomeContainer>
    </>
  );
};

const Main = styled.main`
  min-height: 100vh;
  padding-top: 120px;

  svg {
    width: 0;
    height: 0;
  }
`;

const Bg = styled.div`
  background: repeating-linear-gradient(
    ${primaryColor},
    ${primaryColor} 50%,
    #000 50%,
    #000
  );
  background-size: 5px 5px;
  filter: url(#noise);
  position: absolute;
  top: -50px;
  left: -50px;
  height: calc(100% + 50px);
  width: calc(100% + 50px);
  z-index: -1;
`;

const SliderContainer = styled.section`
  display: flex;
  flex-direction: column;
  justify-content: center;
  min-height: 200px;
`;

const Intro = styled.section`
  padding: 1.5rem;
  line-height: 2.5rem;
  position: relative;

  ${device.laptop} {
    padding-left: 4rem;
    padding-right: 4rem;
  }

  ${device.laptop} {
    padding-left: 5rem;
    padding-right: 5rem;
  }

  br {
    &.phone {
      display: block;

      ${device.tablet} {
        display: none;
      }
    }
  }

  h1 {
    font-size: 2.5rem;
    margin-bottom: 1rem;

    ${device.tablet} {
      font-size: 4rem;
      line-height: 4rem;
      letter-spacing: 0.04em;
    }

    ${device.laptopL} {
      font-size: 6rem;
      line-height: 6rem;
    }
  }

  h2 {
    line-height: 1.25rem;
    font-weight: normal;
    font-size: 1rem;

    ${device.tablet} {
      position: absolute;
      top: 2.25rem;
      left: calc(1.5rem + 306px);
      font-size: 1.25rem;
      line-height: 28px;
    }

    ${device.laptop} {
      left: calc(4rem + 306px);
    }

    ${device.laptopL} {
      top: 3.25rem;
      left: calc(5rem + 460px);
      letter-spacing: 0.02em;
    }
  }
`;

const HomeContainer = styled.div`
  display: flex;
  flex-direction: column;

  > main {
    display: flex;
    flex-direction: column;

    > section {
      flex: 1;
    }

    ${device.laptop} {
      section {
        &:nth-child(2) {
          margin-top: auto;
          flex: 0;
          padding-bottom: 3rem;
        }
      }
    }
  }
`;

const FloatContainer = styled.div`
  position: fixed;
  bottom: 60px;
  right: 1.5rem;

  ${device.laptop} {
    right: 4rem;
    bottom: 3rem;
  }

  ${device.laptopL} {
    right: 5rem;
  }
`;

export const getServerSideProps: GetServerSideProps = async (ctx) => {
  let tags = [];

  try {
    tags = await getTags();
  } catch (err) {
    console.error(err);
  }

  // TODO: use Promise.all
  const metas = await getCaseMetas();

  return {
    props: {
      tags,
      metas,
    },
  };
};

export default Home;
